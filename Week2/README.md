## 1.

### (1) 当 n=2001 时，所求的正整数列是：

```plain
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
```
即全部分解为 3 的情况。
### (2) 首先，算法是如何迈出第一步的？也就是说，在给定正整数 n 的情况下，我们希望找到和为 n 的正整数列表中的最大乘积。

第一步，初始化一个结果变量 `result` 为 1，用于存储最终的最大乘积。然后，我们开始尽可能地将 n 分解为 3。为什么是 3？因为当我们将 n 分解为更大的正整数时，它们的乘积反而会减小。

所以也就是通过一个循环，每次将 n 减去 3，同时将 `result` 乘以 3，直到 n 小于等于 4 为止。此时，n 只能是 2 或 4。如果 n 是 2，就将 `result` 乘以 2；否则，如果 n 是 4，就将 `result` 乘以 4。这是因为 2 和 4 都不能再继续分解。

### (3) 算法实现

```python
def maxProduct(n):
    if n <= 3:
        return n, list(range(1, n+1))
    
    result = 1
    resultList = []

    while n > 4:
        result *= 3
        resultList.extend([3])
        n -= 3
    
    result *= n
    resultList.extend([n])

    return result, resultList

n1 = 5
result1, resultList1 = maxProduct(n1)
print(f"当 n={n1}时，最大乘积为：{result1}")
print(f"正整数列为：{resultList1}")

n2 = 8
result2, resultList2 = maxProduct(n2)
print(f"当 n={n2}时，最大乘积为：{result2}")
print(f"正整数列为：{resultList2}")

```


运行结果：


---
## 2.

代码实现：

```python
result = 2 ** 10
print(f"2^10 = {result}")
result = 2 ** 20
print(f"2^20 = {result}")
result = 2 ** 30
print(f"2^30 = {result}")
result = 2 ** 40
print(f"2^40 = {result}")
result = 2 ** 50
print(f"2^50 = {result}")
```
运行结果：


---
## 5.

代码实现：

```python
def newton_sqrt(c):
    g = c / 2
    while abs(g * g - c) > 1e-10:
        g = (g + c / g) / 2.0
    return g

c_values = [2, 2000]
for c in c_values:
    result = newton_sqrt(c)
    print(f"Square root of {c} ≈ {result:.10f}")
```
运行结果：

---
## 6.

没有影响


---
## 7.

代码实现：

```python
def newton_cbrt(c):
    g = c / 2
    while abs(g**3 - c) > 1e-10:
        g = g - (g**3 - c) / (3 * g**2)
    return g

c = 10
result = newton_cbrt(c)
print(f"Cube root of {c} ≈ {result:.10f}")
```
运行结果：

---
## 8.

代码实现：

```python
import math
import random

# 方法 1: 蒙特卡洛法
def monte_carlo_pi(num_samples):
    inside_circle = 0
    for _ in range(num_samples):
        x = random.uniform(0, 1)
        y = random.uniform(0, 1)
        if x**2 + y**2 <= 1:
            inside_circle += 1
    return 4 * inside_circle / num_samples

# 方法 2: Leibniz 公式
def leibniz_pi(num_terms):
    pi_estimate = 0
    for k in range(num_terms):
        pi_estimate += ((-1)**k) / (2*k + 1)
    pi_estimate *= 4
    return pi_estimate

# 方法 3: 马青公式
def machin_pi(num_terms):
    pi_estimate = 0
    for k in range(num_terms):
        pi_estimate += ((-1)**k) * (4 / (2*k + 1) - 1 / (2*k + 3))
    pi_estimate *= 4
    return pi_estimate

# 比较不同方法的效率和准确性
num_samples = 1000000  # 对于蒙特卡洛法的样本数量
num_terms = 10000      # 对于 Leibniz 和 Machin 的项数

monte_carlo_result = monte_carlo_pi(num_samples)
leibniz_result = leibniz_pi(num_terms)
machin_result = machin_pi(num_terms)

print(f"Monte Carlo π: {monte_carlo_result:.10f}")
print(f"Leibniz π: {leibniz_result:.10f}")
print(f"Machin π: {machin_result:.10f}")
print(f"Python math π: {math.pi:.10f}")
```
运行结果：

---
## 9.

代码实现：

```python
import random

def integrand(x):
    # 定义被积函数 x^2 + 4x * sinx
    return x**2 + 4 * x * (math.sin(x))

def monte_carlo_integration(func, a, b, num_samples):
    integral_sum = 0

    for _ in range(num_samples):
        # 随机生成在区间 [a, b] 上的 x 值
        x = random.uniform(a, b)
        # 计算函数值并累积
        integral_sum += func(x)

    # 计算积分的近似值
    integral_approximation = (b - a) * integral_sum / num_samples
    return integral_approximation

if __name__ == '__main__':
    import math

    a = 2
    b = 3
    num_samples = 1000000  # 采样点数量，此取 1000000

    estimated_integral = monte_carlo_integration(integrand, a, b, num_samples)
    print(f"Estimated Integral: {estimated_integral:.6f}")



```
运行结果：

---
